{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport React, { useState, useCallback, useEffect, useRef } from \"react\";\n\nconst useAnimationFrame = callback => {\n  _s();\n\n  // Use useRef for mutable variables that we want to persist\n  // without triggering a re-render on their change\n  const requestRef = useRef();\n  const previousTimeRef = useRef();\n\n  const animate = time => {\n    if (previousTimeRef.current != undefined) {\n      const deltaTime = time - previousTimeRef.current;\n      callback(deltaTime);\n    }\n\n    previousTimeRef.current = time;\n    requestRef.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    requestRef.current = requestAnimationFrame(animate);\n    return () => cancelAnimationFrame(requestRef.current);\n  }, []); // Make sure the effect runs only once\n};\n\n_s(useAnimationFrame, \"z8M7fn6QAiYOb97lWpO8m/pmXa0=\");\n\nexport const Counter = () => {\n  _s2();\n\n  const [count, setCount] = useState(0);\n  useAnimationFrame(deltaTime => {\n    // Pass on a function to the setter of the state\n    // to make sure we always have the latest state\n    setCount(prevCount => (prevCount + deltaTime * 0.01) % 100);\n  });\n  return count;\n};\n\n_s2(Counter, \"oaakgslE/PS5V9jloHSFhr3VWeo=\", false, function () {\n  return [useAnimationFrame];\n});\n\n_c = Counter;\n\nvar _c;\n\n$RefreshReg$(_c, \"Counter\");","map":{"version":3,"names":["React","useState","useCallback","useEffect","useRef","useAnimationFrame","callback","requestRef","previousTimeRef","animate","time","current","undefined","deltaTime","requestAnimationFrame","cancelAnimationFrame","Counter","count","setCount","prevCount"],"sources":["/Users/barbaramoahamed/Downloads/Globe-main/src/hooks/animation.js"],"sourcesContent":["import React, { useState, useCallback, useEffect, useRef } from \"react\";\n\nconst useAnimationFrame = (callback) => {\n  // Use useRef for mutable variables that we want to persist\n  // without triggering a re-render on their change\n  const requestRef = useRef();\n  const previousTimeRef = useRef();\n\n  const animate = (time) => {\n    if (previousTimeRef.current != undefined) {\n      const deltaTime = time - previousTimeRef.current;\n      callback(deltaTime);\n    }\n    previousTimeRef.current = time;\n    requestRef.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    requestRef.current = requestAnimationFrame(animate);\n    return () => cancelAnimationFrame(requestRef.current);\n  }, []); // Make sure the effect runs only once\n};\n\nexport const Counter = () => {\n  const [count, setCount] = useState(0);\n\n  useAnimationFrame((deltaTime) => {\n    // Pass on a function to the setter of the state\n    // to make sure we always have the latest state\n    setCount((prevCount) => (prevCount + deltaTime * 0.01) % 100);\n  });\n\n  return count;\n};\n"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,WAA1B,EAAuCC,SAAvC,EAAkDC,MAAlD,QAAgE,OAAhE;;AAEA,MAAMC,iBAAiB,GAAIC,QAAD,IAAc;EAAA;;EACtC;EACA;EACA,MAAMC,UAAU,GAAGH,MAAM,EAAzB;EACA,MAAMI,eAAe,GAAGJ,MAAM,EAA9B;;EAEA,MAAMK,OAAO,GAAIC,IAAD,IAAU;IACxB,IAAIF,eAAe,CAACG,OAAhB,IAA2BC,SAA/B,EAA0C;MACxC,MAAMC,SAAS,GAAGH,IAAI,GAAGF,eAAe,CAACG,OAAzC;MACAL,QAAQ,CAACO,SAAD,CAAR;IACD;;IACDL,eAAe,CAACG,OAAhB,GAA0BD,IAA1B;IACAH,UAAU,CAACI,OAAX,GAAqBG,qBAAqB,CAACL,OAAD,CAA1C;EACD,CAPD;;EASAN,SAAS,CAAC,MAAM;IACdI,UAAU,CAACI,OAAX,GAAqBG,qBAAqB,CAACL,OAAD,CAA1C;IACA,OAAO,MAAMM,oBAAoB,CAACR,UAAU,CAACI,OAAZ,CAAjC;EACD,CAHQ,EAGN,EAHM,CAAT,CAfsC,CAkB9B;AACT,CAnBD;;GAAMN,iB;;AAqBN,OAAO,MAAMW,OAAO,GAAG,MAAM;EAAA;;EAC3B,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBjB,QAAQ,CAAC,CAAD,CAAlC;EAEAI,iBAAiB,CAAEQ,SAAD,IAAe;IAC/B;IACA;IACAK,QAAQ,CAAEC,SAAD,IAAe,CAACA,SAAS,GAAGN,SAAS,GAAG,IAAzB,IAAiC,GAAjD,CAAR;EACD,CAJgB,CAAjB;EAMA,OAAOI,KAAP;AACD,CAVM;;IAAMD,O;UAGXX,iB;;;KAHWW,O"},"metadata":{},"sourceType":"module"}